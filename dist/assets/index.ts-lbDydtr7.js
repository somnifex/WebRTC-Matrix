var u=Object.defineProperty;var p=(e,o,t)=>o in e?u(e,o,{enumerable:!0,configurable:!0,writable:!0,value:t}):e[o]=t;var s=(e,o,t)=>p(e,typeof o!="symbol"?o+"":o,t);import{S as r,b as a}from"./storage-BhOQnXRe.js";import{m as b}from"./match-DBrPD0DG.js";class i{static async applyGlobalPolicy(o){let l=(await r.getSettings()).globalPolicy;if(o)try{const n=new URL(o).hostname,d=await r.getRules();b(n,d)==="allow"&&(console.log(`[PrivacyBlocker] Domain ${n} is ALLOWED. Relaxing global policy.`),l="default")}catch{console.warn("[PrivacyBlocker] Invalid context URL:",o)}this.currentPolicy!==l&&(console.log(`[PrivacyBlocker] Applying global policy: ${l} (Context: ${o||"Global"})`),chrome.privacy&&chrome.privacy.network&&chrome.privacy.network.webRTCIPHandlingPolicy?chrome.privacy.network.webRTCIPHandlingPolicy.set({value:l},()=>{chrome.runtime.lastError?console.error("[PrivacyBlocker] Error setting policy:",chrome.runtime.lastError):(console.log("[PrivacyBlocker] Policy set successfully."),this.currentPolicy=l)}):console.warn("[PrivacyBlocker] privacy.network.webRTCIPHandlingPolicy API not available."))}static init(){this.applyGlobalPolicy(),a.storage.onChanged.addListener((o,t)=>{t==="local"&&(o.settings||o.rules)&&this.applyGlobalPolicy()})}}s(i,"currentPolicy",null);console.log("WebRTC Matrix: Background service worker started.");async function c(){try{const e={active:!0,currentWindow:!0},[o]=await a.tabs.query(e);o&&o.url?await i.applyGlobalPolicy(o.url):await i.applyGlobalPolicy()}catch(e){console.error("[Background] Error checking active tab:",e)}}a.runtime.onInstalled.addListener(async()=>{console.log("WebRTC Matrix: Extension installed/updated."),await r.init(),i.init(),c()});a.tabs.onActivated.addListener(()=>{c()});a.tabs.onUpdated.addListener((e,o,t)=>{(o.url||o.status==="complete")&&t.active&&i.applyGlobalPolicy(t.url)});a.windows.onFocusChanged.addListener(e=>{e!==a.windows.WINDOW_ID_NONE&&c()});i.init();
